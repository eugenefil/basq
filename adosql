#!/usr/bin/env winpython3

import sys
import csv
import argparse

import adodbapi


COLUMN_NAME = 0
COLUMN_TYPE = 1
COLUMN_SCALE = 5

CONN_STR_VFP = u'Provider=VFPOLEDB.1;Data Source={datasource};Mode=Share Deny None;Extended Properties="";User ID="";Mask Password=False;Cache Authentication=False;Encrypt Password=False;Collating Sequence=MACHINE;DSN="";DELETED=True;CODEPAGE=1251;MVCOUNT=16384;ENGINEBEHAVIOR=90;TABLEVALIDATE=3;REFRESH=5;VARCHARMAPPING=False;ANSI=True;REPROCESS=5'

CONN_STR_MSSQL = u'Provider=SQLNCLI10;Server={server};Database={database};{auth}'
CONN_STR_MSSQL_SRVAUTH = u'Uid={user};Pwd={password}'
CONN_STR_MSSQL_WINAUTH = u'Integrated Security=SSPI'


def cvtDate(default_conv):
    """Return datetime.date from COM date.

    Default adodbapi converter converts COM date (which is number of
    days since 1899-12-30) to datetime.datetime. This converter extracts
    date from that datetime.
    """
    def todate(com_date):
        return default_conv(com_date).date()
    return todate


def cvtRTrim(s):
    return s.rstrip(' ')


ADO_INTEGER = adodbapi.apibase.DBAPITypeObject(
    adodbapi.apibase.adoIntegerTypes +
    adodbapi.apibase.adoLongTypes
)

def ado_type_to_general(column_info):
    adotype = column_info[COLUMN_TYPE]
    if adotype == adodbapi.STRING:
        return 'string'
    elif adotype == ADO_INTEGER:
        return 'integer'
    elif adotype == adodbapi.NUMBER:
        return 'number'
    elif adotype == adodbapi.DATETIME:
        return 'date'
    raise TypeError('ADO type %s cannot be converted to general type' % adotype)


def execsql(cursor, cmd):
    cursor.execute(cmd)

    columns = []
    for i, desc in enumerate(cursor.description):
        coltype = ado_type_to_general(desc)
        columns.append({'name': desc[COLUMN_NAME], 'type': coltype})

    return cursor, columns


def output_tsv(file, rows, cols, typed_header=False):
    writer = csv.writer(file, delimiter='\t')

    colnamefunc = {
        False: lambda col: col['name'],
        True: lambda col: col['name'] + ' ' + col['type']
    }[typed_header]
    writer.writerow(colnamefunc(c) for c in cols)

    writer.writerows(rows)


def main(connstr, typed_header=False):
    conn = adodbapi.connect(connstr)

    # set proper connection-wide db-to-python type conversions
    conn.variantConversions = adodbapi.apibase.variantConversions
    # convert numeric to float
    conn.variantConversions[adodbapi.ado_consts.adNumeric] = (
        adodbapi.apibase.cvtFloat
    )
    # fixed-width char columns in FoxPro are returned with trailing
    # spaces, so right-trimming is necessary
    conn.variantConversions[adodbapi.ado_consts.adChar] = cvtRTrim
    # convert pure date to date, not datetime
    conn.variantConversions[adodbapi.ado_consts.adDBDate] = cvtDate(
        conn.variantConversions[adodbapi.ado_consts.adDBDate]
    )

    cur = conn.cursor()
    for sqlcmd in sys.stdin:
        results = execsql(cur, sqlcmd)
        if results:
            rows, cols = results
            output_tsv(sys.stdout, rows, cols, typed_header)

    cur.close()
    conn.close()


def vfpconnstr(args):
    return CONN_STR_VFP.format(datasource=args.database)


def mssqlconnstr(args):
    auth = CONN_STR_MSSQL_WINAUTH
    if args.user:
        auth = CONN_STR_MSSQL_SRVAUTH.format(
            user=args.user,
            password=args.password
        )
    return CONN_STR_MSSQL.format(
        auth=auth,
        server=args.server,
        database=args.database
    )


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '-typed-header',
        action='store_true',
        help='output typed header. Each column will contain its type delimited from name by space'
    )

    subparsers = parser.add_subparsers(title='commands')

    vfpparser = subparsers.add_parser(
        'vfp',
        help='Visual FoxPro'
    )
    vfpparser.add_argument(
        'database',
        help='path to .dbc database file'
    )
    vfpparser.set_defaults(getconnstr=vfpconnstr)

    mssqlparser = subparsers.add_parser(
        'mssql',
        description='Windows Authentication is used by default',
        help='Microsoft SQL Server'
    )
    mssqlparser.add_argument(
        '-server',
        default='localhost',
        help='server ip/name. Default: localhost',
        metavar='SRV'
    )
    mssqlparser.add_argument(
        '-database',
        default='',
        help='initial database. Default: server settings',
        metavar='DB'
    )
    mssqlparser.add_argument(
        '-user',
        help='user name for SQL Server Authentication'
    )
    mssqlparser.add_argument(
        '-password',
        default='',
        help='password for SQL Server Authentication',
        metavar='PASS'
    )
    mssqlparser.set_defaults(getconnstr=mssqlconnstr)
    
    return parser.parse_args()


def setup():
    # Redefine stdout to not translate newlines, because csv writer writes \r\n
    # (as per rfc 4180). If translated on Windows, \r\n becomes \r\r\n. Also
    # always use utf-8.
    sys.stdout = open(
        sys.stdout.fileno(),
        mode=sys.stdout.mode,
        encoding='utf-8',
        errors=sys.stdout.errors,
        newline='',
        closefd=False
    )


if __name__ == '__main__':
    args = parse_args()
    setup()
    main(args.getconnstr(args), args.typed_header)
